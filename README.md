# AI-Checkers
Checkers Game developed for AI class at Cooper Union Fall 2020


This Artificial intelligence Checkers program implements an iterative deepening minimax search with alpha-beta pruning. This code was created, compiled, and run in Visual Studio on a Windows computer. The program uses an ASCII text interface to display the 8x8 checkers board. The program checks for all legal moves of each piece on the board, displaying them whenever a board is printed. This looks at all possible directions the piece can move in (depending on if it’s a king or normal piece), and checks for free spaces, or for opposing players with a free space behind them, and then like a tree search, checks again from the new position, keeping track of the opposing players that move would have captured to avoid repeat moves. Additionally, this allows for the piece to end up back at the same spot, which I had trouble with. A data structure called “Move” is used, that stores the legal move from a current player’s piece, as well as the checkers board that would result if that move were selected. It also holds an integer value for the evaluation function value called “score”, and an integer value named “value” which keeps track of the amount of enemy pieces that said move would capture. This tree is constructed via the legal moves function, and is searched until a time limit is reached, or until a cutoff depth of 15 is reached. 
The pieces are assigned values as follows: 
•	0 = empty
•	3 = player 1 normal piece (aka man)
•	5 = player 1 king
•	-3 = player 2 normal piece
•	-5 = player 3 king
The option to load in a file is prompted first. This gives the user the option to load in a text file with a specific format that can be used to load in a board, time limit for the computer, and dictates which player’s move it is. Instructions for the text file format are included if the user chooses to load a file. The format follows what is posted on http://faculty.cooper.edu/sable2/courses/fall2020/ece469/#projects.
If a file is not loaded, the user is able to input a time limit for the computer, as well as which player moves first, and which player will be played by the computer (both or neither player can be selected as a computer player).
When started, the program prints a board with the pieces, and legal moves are shown at the bottom, with a “Move #.” In order to enact a move, the user chooses the move number they would like to perform by inputting the integer with the corresponding piece locations.
This version implements force jumps, meaning that if given the opportunity, a player must take a move that forces them to jump over the opposing piece. All intermediate moves are shown for a jumping move.
The game reports how long the computer search took, and reports the maximum depth searched by the computer. If the search gets cut off, the program reports that this happened and reports which depth of search it is using its results from. 
The evaluation function takes a few factors into account. If there are no enemy pieces left, then a victory is declared for the agent with a large positive value. If there are no more friendly pieces left, then a victory is declared for the opposing player with a large negative value. The evaluation function is different for different parts of the match. When the total value of the absolute value of all pieces on the board is above 31 points (following the point scheme from above), the following value is returned:
-	Absolute value of enemy points taken up by a move, multiplied by 10.
-	Absolute value of enemy points remaining, multiplied by -10 (negative to minimize the opposing player’s pieces on the board).
-	Absolute value of friendly points remaining, multiplied by 15 (to maximize the number of friendly points available, and to favor gaining kings).
-	An edges contribution which gives positive points to the state for having friendly pieces on the edges of the board and for having its original normal pieces on the home row of the board, and subtracts value to the state for having enemy pieces on the edges of the board and for having original normal pieces in the enemies home row. Each value is multiplied by 10.
-	A distances contribution, which adds up the Pythagorean distance between every single piece on the board, divided by -10 (negative to minimize the distance contribution).
In the later stages of the game, when the absolute value of the points of all pieces combined is less than 30 (for example, if each player has 3 kings), then an evaluation function that only takes game-winning scenarios, as well as the total distance between pieces into account is used. This surprisingly works very well for some reason. I am unable to explain why this works, however I think working in conjunction with determining game winning states creates for a relatively strong evaluation function that will at least force a draw. (I found this evaluation function to work very well by pure luck. I forgot to type a “return” at the beginning of my return statement in my evaluation function, and only returned the negative distance at the end of the statement, and this evaluation function happened to work very well for states where both players had few pieces. 
The game is declared a draw when 40 moves have passed and neither plater has lost any pieces. The program indicates a warning of a draw when there are 31, 30, 21, 21, and 10 or less moves without any pieces lost by either player. The game is declared over if a player has no legal moves. The player without any legal moves loses. This generally occurs when a player has lost all their pieces. This may also occur is a player has pieces which are unable to move anywhere. The game congratulates either player that wins with an unfunny rhyme. 
The program takes advantage of terminal coloring to make the game a little more vibrant with whiter whites and brighter colors than are available with general terminal text on a windows computer.
This was a really difficult project, just like you said. I not only got to learn how to implement the artificial intelligence algorithms we learned in class, but I also taught myself some material on data structures and algorithms as well as learning how to code in C++. It is my favorite project that I have done while at Cooper. I learned an incredible amount and the whole process was extremely rewarding. This was a great experience. Thank you for letting me waive the prerequisite for this course.


